<h2>Introduction</h2><h3>Executable Documentation</h3><p>Everything in this documentation is executed as part of the build process, so all the examples are guaranteed to run with the latest master branch of Dollar.</p><p>Yep Dollar can actually run Markdown files, in fact the source file that this page was built from starts with:</p>
<pre><code>#!/usr/bin/env dollar
</code></pre><p>So it can be executed directly from a Unix command line.</p><p>The source for this page (minus that header) is <a href="scripting.md">here</a></p><h3>Getting Started</h3><p>NOTE: At present only Mac OS X and 64 Bit Ubuntu Linux is officially supported, however since Dollar is entirely based in Java it's trivial to port to other systems.</p><p>First download the Dollar scripting runtime from <a href="https://bintray.com/neilellis/dollar/dollarscript/_latestVersion"> <img src="https://api.bintray.com/packages/neilellis/dollar/dollarscript/images/download.svg" alt="Download""/> </a></p><p>Make sure <code>dollar/bin</code> is on your PATH.</p><p>Run <code>dollar &lt;filename&gt;</code> to execute a Dollar script.</p><p>Here is an example of what DollarScript looks like</p>
<pre><code class="dollar"><br/>testParams := ($2 + &quot; &quot; + $1)

.: testParams (&quot;Hello&quot;, &quot;World&quot;) == &quot;World Hello&quot;

</code></pre><h2>Understanding the Basics</h2><p>DollarScript has it's own peculiarities, mostly these exists to help with it's major function - data/API centric Internet applications. So it's important to understand the basic concepts before getting started.</p><h3>Functional Programming</h3><p>Support for functional programming is included in DollarScript, this will be widened as the language is developed. For now it is provided by the <code>pure</code> operator. This signals that an expression or declaration is a pure expression or function.</p><p>In this example we're declaring reverse to be an expression that reverses two values from a supplied array. Because we declare it as <code>pure</code> the expression supplied must also be <code>pure</code>. To understand what a pure function is please see http://en.wikipedia.org/wiki/Pure_function. Basically it prohibits the reading of external state or the setting of external state. We next swap <code>[2,1]</code> within a newly created pure expression, which is subsequently assigned to a. If reverse had not been declared pure it would not be allowed within the pure expression.</p><p>```dollar  pure reverse := [$1[1],$1[0]]</p><p>a= pure {  reverse([2,1])  }</p><p>```</p><p>Note some builtin functions are not themselves pure and will trigger parser errors if you attempt to use them in a pure expression. Take DATE() for example which supplies an external state (the computers clock).</p><h3>Reactive Programming</h3><p>DollarScript expressions are by default <em>lazy</em>, this is really important to understand otherwise you may get some surprises. This lazy evaluation is combined with a simple event system to make DollarScript a <a href="http://en.wikipedia.org/wiki/Reactive_programming">reactive programming language</a> by default.</p><p>Let's see some of that behaviour in action:</p>
<pre><code class="dollar"><br/>variableA := 1
variableB := variableA
variableA := 2

.: variableB == 2
</code></pre><p>In the above example we are declaring (using the declarative operator <code>:=</code>) that variableA is current the value 1, we then declare that variableB is the <em>same as</em> variableA. So when we change variableA to 2 we also change variableB to 2.</p><p>The assertion operator <code>.:</code> will throw an assertion error if the value following is either non boolean or not true.</p><p>Now let's throw in the causes operator :</p>
<pre><code class="dollar"><br/>a=1
a causes { @@ $1 }
a=2
a=3
a=4

</code></pre>
<pre><code>2
3
4
</code></pre><p>That simple piece of code will simply output each change made to the variable a, but wait a minute what about ...</p>
<pre><code class="dollar"><br/>b=1
a=1
a + b + 1 causes { @@ &quot;a=&quot; + a + &quot;, b=&quot; + b}
a=2
a=3
a=4
b=2
</code></pre>
<pre><code>a=2, b=1
a=3, b=1
a=4, b=1
a=4, b=2
</code></pre><p>Yep, you can write reactive expressions based on collections or arbitrary expressions. When any component changes the right hand side is re-evaluated (the actual value that changed is passed in as $1).</p><p>But it's even simpler than that, many of DollarScripts operators are reactive themselves. That means they understand changes to their values. Take <code>@@</code> (or <code>print</code>) as an example:</p>
<pre><code class="dollar">b=1
@@b
b=2
</code></pre><p>Outputs 1 then 2 because @@ heard the change to b and re output the new value. Often this is what you want, however if you don't just add the fix operator <code>&amp;</code> before the value. That will stop reactive behaviour.</p>
<pre><code class="dollar">b=1
@@ &amp;b
b=2
</code></pre><h3>Assignment</h3><p>Obviously the declarative/reactive behavior is fantastic for templating, eventing, creating lambda style expressions etc. however a lot of the time we want to simply assign a value and perform a single action on that value.</p>
<pre><code class="dollar"><br/>variableA = 1
variableB = variableA
variableA = 2

.: variableB == 1
</code></pre><p>So as you can see when we use the <code>=</code> assignment operator we assign the <em>value</em> of the right hand side to the variable. Watch what happens when we use expressions.</p>
<pre><code class="dollar"><br/>variableA = 1
variableB = variableA
variableC = (variableA +1 )
variableD := (variableA + 1)
variableA = 2

.: variableB == 1
.: variableC == 2
.: variableD == 3

</code></pre><p>The assignment operator <code>=</code> has a 'fix' depth of 1. This means that any expression will be evaluated, but no maps or line blocks will be. It is also not reactive. A fix depth of 2 causes all expressions to be evaluated and evaluates one depth of maps or line blocks.</p>
<pre><code class="dollar"><br/>lamdaVar = {$1 + 10}
lamdaVar(5) &lt;=&gt; 15

</code></pre><p>The assert equals operator <code>&lt;=&gt;</code> will compare two values and throw an exception if they are not the same.</p><p>It's important to note that all values in DollarScript are immutable - that means if you wish to change the value of a variable you <em>must</em> <strong>reassign</strong> a new value to the variable. For example <code>v++</code> would return the value of <code>v+1</code> it does not increment v. If however you want to assign a constant value, one that is both immutable and cannot be reassigned, just use the <code>const</code> modifier at the variable assignment (this does not make sense for declarations, so is only available on assignments).</p>
<pre><code class="dollar">const MEDIUM = 23
// MEDIUM= 4 would now produce an error
</code></pre><p>So <code>:=</code> supports the full reactive behaviour of Dollar, i.e. it is a declaration not a value assignment, and <code>=</code> is used to nail down a particular value or reduce the reactive behaviour. Later we'll come across the fix operator <code>&amp;</code> which instructs DollarScript to fix a value completely . More on that later.</p><h3>Blocks</h3><h4>Line Block</h4><p>DollarScript supports several block types, the first is the 'line block' a line block lies between <code>{</code> and <code>}</code> and is separated by either newlines or <code>;</code> characters.</p>
<pre><code class="dollar"><br/>myBlock := {
    &quot;Hello &quot;
    &quot;World&quot;
}

myBlock &lt;=&gt; &quot;World&quot;

myBlock2 := {1;2}

myBlock2 &lt;=&gt; 2

</code></pre><p>When a line block is evaluated the result is the value of the last entry. For advanced users note that all lines will be evaluated, the value is just ignored. A line block behaves a lot like a function in an imperative language.</p><h4>List Block</h4><p>Next we have the list block, the list block preserves all the values each part is seperated by either a <code>,</code> or a newline but is delimited by <code>[</code> and <code>]</code>.</p>
<pre><code class="dollar"><br/>list := [
    &quot;Hello &quot;
    &quot;World&quot;
]

list &lt;=&gt; [&quot;Hello &quot;,&quot;World&quot;]

list2 := [1,2]

list2 &lt;=&gt; [1,2]

</code></pre><h4>Map Block</h4><p>Finally we have the map block, when an map block is evaluated the result is the aggregation of the parts from top to bottom into a map. The map block starts and finishes with the <code>{</code> <code>}</code> braces, however each part is seperated by a <code>,</code> not a <code>;</code> or <em>newline</em> . The default behaviour of a map block is virtually useless, it takes the string value and makes it the key and keeps the original value as the value to be paired with that key.</p>
<pre><code class="dollar"><br/>mapBlock := {
    &quot;Hello&quot;,
    &quot;World&quot;
}

mapBlock &lt;=&gt; {&quot;Hello&quot;:&quot;Hello&quot;, &quot;World&quot;:&quot;World&quot;}

mapBlock2 := { 1, 2}

mapBlock2 &lt;=&gt; {&quot;1&quot;:1,&quot;2&quot;:2}

</code></pre><p>Map blocks are combined with the pair <code>:</code> operator to become useful and create maps/JSON like this:</p>
<pre><code class="dollar"><br/>mapBlock := {
    &quot;first&quot;:&quot;Hello &quot;,
   &quot;second&quot;:&quot;World&quot;
}

@@ mapBlock

mapBlock.second &lt;=&gt; &quot;World&quot;

</code></pre><p>A map block with one entry that is not a pair is assumed to be a <em>Line Block</em>.</p><p>The stdout operator <code>@@</code> is used to send a value to stdout in it's serialized (JSON) format, so the result of the above would be to output <code>{&quot;first&quot;:&quot;Hello &quot;,&quot;second&quot;:&quot;World&quot;}</code> a JSON object created using JSON like syntax. Maps can also be created by joining pairs.</p>
<pre><code class="dollar"><br/>pair1 := &quot;first&quot; : &quot;Hello &quot;;
pair2 := &quot;second&quot; : &quot;World&quot;;

.: pair1 + pair2 == {&quot;first&quot;:&quot;Hello &quot;,&quot;second&quot;:&quot;World&quot;}

</code></pre><h3>Lists</h3><p>DollarScript's lists are pretty similar to JavaScript arrays. They are defined using the <code>[1,2,3]</code> style syntax and accessed using the <code>x[y]</code> subscript syntax.</p>
<pre><code class="dollar">.: [1,2,3] + 4 == [1,2,3,4];
.: [1,2,3,4] - 4 == [1,2,3];
.: [] + 1 == [1] ;
.: [1] + [1] == [1,1];
.: [1] + 1 == [1,1];

[1,2,3][1] &lt;=&gt; 2

</code></pre><p><em>Note we're using the assert equals or <code>&lt;=&gt;</code> operator here, this is a combination of <code>.:</code> and <code>==</code> that will cause an error if the two values are not equal.</em></p><p>You can count the size of the list using the size operator <code>#</code>.</p>
<pre><code class="dollar">#[1,2,3,4] &lt;=&gt; 4
</code></pre><p>DollarScript maps are also associative arrays (like JavaScript) allowing you to request members from them using the list subscript syntax</p>
<pre><code class="dollar">{&quot;key1&quot;:1,&quot;key2&quot;:2} [&quot;key&quot;+1] &lt;=&gt; 1
{&quot;key1&quot;:1,&quot;key2&quot;:2} [1] &lt;=&gt; {&quot;key2&quot;:2}
{&quot;key1&quot;:1,&quot;key2&quot;:2} [1][&quot;key2&quot;] &lt;=&gt; 2
</code></pre><p>As you can see from the example you can request a key/value pair (or Tuple if you like) by it's position using a numeric subscript. Or you can treat it as an associative array and request an entry by specifying the key name. Any expression can be used as a subscript, numerical values will be used as indexes, otherwise the string value will be used as a key.</p><h3>Ranges</h3><p>DollarScript (at present) supports numerical and character ranges</p>
<pre><code class="dollar"><br/>#(&quot;a&quot;..&quot;c&quot;) &lt;=&gt; 3
(1..3)[1] &lt;=&gt;2

</code></pre><h3>Error Handling</h3><p>Error handling couldn't be simpler. Define an error expression using the error keyword, the expression supplied will be evaluated on an error occurring within any sub scope of the scope in which it is defined. The special variables <code>msg</code> and <code>type</code> will be assigned values.</p>
<pre><code class="dollar">errorHappened= false
error { @@ msg; errorHappened= true }
a=1/0
.: errorHappened
</code></pre><h2>Type System</h2><h3>Intro</h3><p>Although DollarScript is typeless at compile time, it does support basic runtime typing. At present this includes: STRING, INTEGER,DECIMAL, LIST, MAP, URI, VOID, RANGE, BOOLEAN. The value for a type can be checked using the <code>is</code> operator:</p>
<pre><code class="dollar">.: &quot;Hello World&quot; is String
.: [&quot;Hello World&quot;] is List
</code></pre><h3>Date</h3><p>Dollar supports a decimal date system where each day is 1.0. This means it's possible to add and remove days from a date using simple arithmetic.</p>
<pre><code class="dollar">@@ DATE()
@@ DATE() + 1
@@ DATE() - 1

.: DATE() + &quot;1.0&quot; is String
.: DATE() / &quot;1.0&quot; is Decimal
</code></pre><p>Components of the date can be accessed using the subscript operators:</p>
<pre><code class="dollar">@@ DATE().DAY_OF_WEEK

@@ DATE()[&#39;DAY_OF_YEAR&#39;]=1
</code></pre><p>Valid values are those from <code>java.time.temporal.ChronoField</code></p>
<pre><code>NANO_OF_SECOND, NANO_OF_DAY, MICRO_OF_SECOND, MICRO_OF_DAY, MILLI_OF_SECOND, MILLI_OF_DAY, SECOND_OF_MINUTE, SECOND_OF_DAY, MINUTE_OF_HOUR, MINUTE_OF_DAY, HOUR_OF_AMPM, CLOCK_HOUR_OF_AMPM, HOUR_OF_DAY, CLOCK_HOUR_OF_DAY, AMPM_OF_DAY, DAY_OF_WEEK, ALIGNED_DAY_OF_WEEK_IN_MONTH, ALIGNED_DAY_OF_WEEK_IN_YEAR, DAY_OF_MONTH, DAY_OF_YEAR, EPOCH_DAY, ALIGNED_WEEK_OF_MONTH, ALIGNED_WEEK_OF_YEAR, MONTH_OF_YEAR, PROLEPTIC_MONTH, YEAR_OF_ERA, YEAR, ERA, INSTANT_SECONDS, OFFSET_SECONDS
</code></pre><p>As you can see we can do date arithmetic, but thanks to another DollarScript feature anything that can be specified as xxx(i) can also be written i xxx (where i is an integer or decimal and xxx is an identifier). So we can add days hours and seconds to the date.</p>
<pre><code class="dollar">@@ DATE() + 1 Day
@@ DATE() + 1 Hour
@@ DATE() + 1 Sec
</code></pre><p>Those values are built in, but we can easily define them ourselves.</p>
<pre><code class="dollar">fortnight := ($1 * 14)

@@ DATE() + 1 fortnight
</code></pre><h3>Constraints</h3><p>Although there are no compile type constraints in DollarScript a runtime type system can be built using constraints. Constraints are declared at the time of variable assignment or declaration. A constraint once declared on a variable cannot be changed. The constraint is placed before the variable name at the time of declaration in parenthesis.</p>
<pre><code class="dollar">(it &lt; 100) a = 50
(it &gt; previous || previous is Void) b = 5
b=6
b=7
( it is String) s=&quot;String value&quot;
</code></pre><p>The special variables <code>it</code> - the current value and <code>previous</code> - the previous value, will be available for the constraint.</p><p>To build a simple type system simply declare (using <code>:=</code>) your type as a boolean expression.</p>
<pre><code class="dollar"><br/>//define a pseudo-type
colorEnum := ( it in [&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;] )


//Use it as a constraint
(colorEnum) myColor= &quot;green&quot;

error { @@ msg }

//This fails
myColor=&quot;apple&quot;

</code></pre><p>Of course since the use of <code>(it is XXXX)</code> is very common DollarScript provides a specific runtime type constraint that can be added in conjunction with other constraints. Simply prefix the assignment or decleration with <code>&lt;XXXX&gt;</code> where XXXX is the runtime type.</p>
<pre><code class="dollar">&lt;string&gt; (#it &gt; 5) s=&quot;String value&quot;
</code></pre><h3>Type Coercion</h3><p>DollarScript also supports type coercion, this is done using the <code>as</code> operator followed by the type to coerce to.</p>
<pre><code class="dollar">&lt;string&gt; s= 1 as string
s &lt;=&gt; &quot;1&quot;
</code></pre><p>A few more examples follow.</p>
<pre><code class="dollar">1 as string &lt;=&gt; &quot;1&quot;
1 as boolean &lt;=&gt; true
1 as list &lt;=&gt; [1]
1 as map &lt;=&gt; {&quot;value&quot;:1}
1 as VOID &lt;=&gt; void
1 as integer &lt;=&gt; 1

&quot;1&quot; as integer &lt;=&gt; 1
&quot;http://google.com&quot; as uri
&quot;1&quot; as VOID &lt;=&gt; void
&quot;true&quot; as boolean &lt;=&gt; true
&quot;1&quot; as boolean &lt;=&gt; false
&quot;1&quot; as list &lt;=&gt; [&quot;1&quot;]
&quot;1&quot; as map &lt;=&gt; {&quot;value&quot;:&quot;1&quot;}
&quot;1&quot; as string &lt;=&gt; &quot;1&quot;

true as string &lt;=&gt; &quot;true&quot;
true as integer &lt;=&gt; 1
true as list &lt;=&gt; [true]
true as map &lt;=&gt; {&quot;value&quot;:true}
true as boolean &lt;=&gt; true
true as VOID &lt;=&gt; void


[1,2,3] as string &lt;=&gt; &quot;[ 1, 2, 3 ]&quot;
[1,2,3] as list &lt;=&gt; [1,2,3]
[1,2,3] as boolean &lt;=&gt; true
[1,2,3] as map &lt;=&gt; {&quot;value&quot;:[1,2,3]}

{&quot;a&quot;:1,&quot;b&quot;:2} as string &lt;=&gt; &#39;{&quot;a&quot;:1,&quot;b&quot;:2}&#39;
{&quot;a&quot;:1,&quot;b&quot;:2} as list &lt;=&gt; [&quot;a&quot;:1,&quot;b&quot;:2]
{&quot;a&quot;:1,&quot;b&quot;:2} as boolean &lt;=&gt; true
{&quot;a&quot;:1,&quot;b&quot;:2} as VOID &lt;=&gt; void
</code></pre><h2>Imperative Control Flow</h2><p>With imperative control flow, the control flow operations are only triggered when the block they are contained within is evaluated. I.e. they behave like control flow in imperative languages. So start with these if you're just learning DollarScript.</p><h3>If</h3><p>DollarScript supports the usual imperative control flow but, unlike some languages, everything is an operator. This is the general rule of DollarScript, everything has a value. DollarScript does not have the concept of statements and expressions, just expressions. This means that you can use control flow in an expression.</p>
<pre><code class="dollar"><br/>a=1
b= if a==1 2 else 3
b &lt;=&gt; 2

</code></pre><p>So let's start with the <code>if</code> operator. The <code>if</code> operator is separate from the <code>else</code> operator, it simply evaluates the condition supplied as the first argument. If that value is boolean and true it evaluates the second argument and returns it's value; otherwise it returns boolean false.</p><p>The <code>else</code> operator is a binary operator which evaluates the left-hand-side (usually the result of an <code>if</code> statement), if that has a value of false then the right-hand-side is evaluated and it's result returned, otherwise it returns the left-hand-side.</p><p>The combined effect of these two operators is to provide the usual if/else/else if/ control flow</p>
<pre><code class="dollar"><br/>a=5
//Parenthesis added for clarity, not required.
b= if (a == 1) &quot;one&quot; else if (a == 2) &quot;two&quot; else &quot;more than two&quot;
.: b == &quot;more than two&quot;

</code></pre><h3>For</h3>
<pre><code class="dollar"><br/>for i in 1..10 {
    @@ i
}

</code></pre><h3>While</h3>
<pre><code class="dollar">a= 1
while a &lt; 10 {
 a= a+1
}
a &lt;=&gt; 10

</code></pre><h2>Reactive Control Flow</h2><h3>Causes</h3><p>DollarScript as previously mentioned is a reactive programming language, that means that changes to one part of your program can automatically affect another. Consider this a 'push' model instead of the usual 'pull' model.</p><p>Let's start with the simplest reactive control flow operator, the '?-&gt;' or 'causes' operator.</p>
<pre><code class="dollar">a=1; b=1

a ?-&gt; (b= a)

&amp;a &lt;=&gt; 1 ; &amp;b &lt;=&gt; 1

a=2 ; &amp;a &lt;=&gt; 2 ; &amp;b &lt;=&gt; 2

</code></pre><p>Okay so reactive programming can melt your head a little. So let's go through the example step by step.</p><p>Firstly we assign fixed values to <code>a</code> and <code>b</code>, we then say that when <code>a</code> changes the action we should take is to assign it's value to <code>b</code>. Okay now we check to see if the current value of <code>a</code> is equal to 1, we use the fix operator <code>&amp;</code> here to say that we are only interested in the current value. Because <code>&lt;=&gt;</code> is a reactive operator if we didn't use the fix operator then <code>a &lt;=&gt; 1</code> would mean a is always 1. When we add the fix operator it fixes the value of a to the value at this point in the code.</p><p>We then do the same with b to see if it is 1.</p><p>Next we assign a new value of 2 to <code>a</code>. This will immediately (within the same thread) trigger the reactive <code>-&gt;</code> operator which is triggered by changes to <code>a</code>. The trigger assigns the value of <code>a</code> to <code>b</code>, so <code>b</code> is now the same as <code>a</code>. The assertions at the end confirm this.</p><h3>When</h3><p>Next we have the 'when' operator which can be specified as a statement, usually for longer pieces of code. Or as the <code>?</code> operator, for concise code.</p>
<pre><code class="dollar"><br/>c=1
d=1

//When c is greater than 3 assign it&#39;s value to d
c &gt; 3 ? (d= c)

&amp;c &lt;=&gt; 1; &amp;d &lt;=&gt; 1
c=2; &amp;c &lt;=&gt; 2; &amp;d &lt;=&gt; 1
c=5 ; &amp;c &lt;=&gt; 5 ; &amp;d &lt;=&gt; 5

</code></pre><p>This is similar to the previous example except that we have to set a value greater than 3 for the action to be taken.</p>
<pre><code class="dollar">//Note alternative syntax is when &lt;condition&gt; &lt;expression&gt;
c=1
when c &gt; 3 { @@ c}
</code></pre><h3>Collect</h3><p>The <code>collect</code> operator listens for changes in the supplied expression adding all the values to a list until the <code>until</code> clause is triggered. It then evaluates the second expression with the values <code>it</code> for the current value, <code>count</code> for the number of messages <strong>received</strong> since last emission and <code>collected</code> for the collected values. The whole operator itself emits <code>void</code> unless the collection operation is triggered in which case it emits the collection itself. Values can be skipped with an <code>unless</code> clause. Skipped messages increase the count value, so use <code>#collected</code> if you want the number of collected values.</p>
<pre><code class="dollar"><br/>e=void

//Length is greater than or equal to 4 unless void
(#it &gt;= 4 || it is VOID) collectedValues=void

//count starts at 0 so this means five to collect (except if it contains the value 10)
collect e until count == 4 unless it == 10{
    print count
    print collected
    collectedValues= collected
}

e=1; e=2; e=3; e=4; e=5; e=6
&amp;collectedValues &lt;=&gt; [1,2,3,4,5]
e=7; e=8; e=9; e=10
&amp;collectedValues &lt;=&gt; [6,7,8,9]
e=11; e=12; e=13; e=14; e=15; e=16
&amp;collectedValues &lt;=&gt; [11,12,13,14,15]

</code></pre><h2>Parameters &amp; Functions</h2><p>In most programming languages you have the concept of functions and parameters, i.e. you can parametrized blocks of code. In DollarScript you can parameterize <em>anything</em>. For example let's just take a simple expression that adds two strings together, in reverse order, and pass in two parameters.</p>
<pre><code class="dollar">($2 + &quot; &quot; + $1)(&quot;Hello&quot;, &quot;World&quot;) &lt;=&gt; &quot;World Hello&quot;

</code></pre><p>The naming of positional parameters is the same as in shell scripts.</p><p>Now if we take this further we can use the declaration operator <code>:=</code> to say that a variable is equal to the expression we wish to parameterise, like so:</p>
<pre><code class="dollar"><br/>testParams := ($2 + &quot; &quot; + $1)
testParams (&quot;Hello&quot;, &quot;World&quot;) &lt;=&gt; &quot;World Hello&quot;

</code></pre><p>Yep we built a function just by naming an expression. You can name anything and parameterise it - including maps, lists, blocks and plain old expressions.</p><p>What about named parameters, that would be nice.</p>
<pre><code class="dollar">testParams := (last + &quot; &quot; + first)
testParams(first=&quot;Hello&quot;, last=&quot;World&quot;) &lt;=&gt; &quot;World Hello&quot;
</code></pre><p>Yep you can use named parameters, then refer to the values by the names passed in.</p><h2>Resources &amp; URIs</h2><p>URIs are first class citizen's in DollarScript. They refer to a an arbitrary resource, usually remote, that can be accessed using the specified protocol and location. Static URIs can be referred to directly without quotation marks, dynamic URIs can be built by casting to a uri using the <code>as</code> operator.</p>
<pre><code class="dollar">search=&quot;Unikitty&quot;

dynamicURI= (&quot;camel:http://google.com?q=&quot;+search) as uri

marinaVideos = &lt;&lt; https://itunes.apple.com/search?term=Marina+And+The+Diamonds&amp;entity=musicVideo
@@ marinaVideos.results each { $1.trackViewUrl }
</code></pre><p>In this example we've requested a single value (using <code>&lt;&lt;</code>) from a uri and assigned the value to <code>marinaVideos</code> then we simply iterate over the results using <code>each</code> and each value (passed in to the scope as <code>$1</code>) we extract the <code>trackViewUrl</code>. The each operator returns a list of the results and that is what is passed to standard out.</p><h2>Using Java</h2><p>Hopefully you'll find DollarScript a useful and productive language, but there will be many times when you just want to quickly nip out to a bit of Java. To do so, just surround the Java in backticks.</p>
<pre><code class="dollar"><br/>variableA=&quot;Hello World&quot;

java = `out=scope.get(&quot;variableA&quot;);`

java &lt;=&gt; &quot;Hello World&quot;

</code></pre><p>A whole bunch of imports are done for you automatically (java.util.*, java.math.*) but you will have to fully qualify any thirdparty libs. The return type will be of type <code>var</code> and is stored in the variable <code>out</code>. The Java snippet also has access to the scope (com.sillelien.dollar.script.api.Scope) object on which you can get and set DollarScript variables.</p><p>Reactive behaviour is supported on the Scope object with the listen and notify methods on variables. You'll need to then built your reactivity around those variables or on the <code>out</code> object directly (that's a pretty advanced topic).</p><h2>Operators</h2><h3>Iterative Operators</h3><h3>Comparison Operators</h3><h3>Numerical Operators</h3><p>DollarScript support the basic numerical operators +,-,/,*,% as well as #</p><h3>Logical Operators</h3><p>DollarScript support the basic logical operators &amp;&amp;,||,! as well as the truthy operator <code>~</code></p><p>The truthy operator converts any value to a boolean by applying the rule that: void is false, 0 is false, "" is false, empty list is false, empty map is false - all else is true.</p>
<pre><code class="dollar"><br/>.: ~ [1,2,3]
.: ! ~ []
.: ~ &quot;anything&quot;
.: ! ~ &quot;&quot;
.: ~ 1
.: ! ~ 0
.: ! ~ {void}
.:  ~ {&quot;a&quot; : 1}
.: ! ~ void

</code></pre><h3>Pipe Operators</h3><h3>Remaining Operators</h3><h2>Imports &amp; Modules</h2><h3>Import</h3><h3>Modules</h3><p>Modules can be imported using the <code>module</code> keyword and a string representing in URI format the location of the module. At present the standard format is the Github locator so we're going to look at that first.</p>
<pre><code class="dollar">chat:= module &quot;github:neilellis:dollar-example-module::chat.ds&quot; (channel=&quot;test&quot;)
sub= chat.server()
chat.stop()
</code></pre><p>Let's start by breaking down the module URI. Okay our first part says it's the GitHub scheme and so the GitHub module locator will be used. Next we say the repository belongs to neilellis and the repository is called dollar-example-module. The next part is the optional branch indicator - here we are using the master, so we just leave that empty. Finally we can optionally supply the name of a single script we want to import. If we don't provide that then the main script from the modules 'module.json' file will be used.</p><p>The source for the module can be found here: https://github.com/neilellis/dollar-example-module</p><p>You will need to have the following file '~/.github' and it should have contents that look like:</p>
<pre><code>login=neilellis
password=whatsupdoc
</code></pre><p>The GitHub resolver will checkout the specified repository and store it under <code>~/.dollar/repo/&lt;username&gt;/&lt;repo-name&gt;/&lt;branch&gt;</code> all further interaction with the module will then be done from the checked out version. If you already have a version checked out a git pull will be done to update the branch.</p>
<pre><code class="dollar">hello := module &quot;github:neilellis:dollar-example-module:0.1.0:branch.ds&quot;
@@ hello
</code></pre><h3>Module Locators</h3><h3>Writing Modules</h3><p>Modules consist of a file called module.json with the name of the main script for the module and an optional array of Maven style java dependencies. And then one or more DollarScript files.</p>
<pre><code>{
&quot;main&quot;:&quot;chat.ds&quot;,
&quot;dependencies&quot;:[&quot;org.twitter4j:twitter4j-core:4.0.2&quot;]
}
</code></pre><p>The DollarScript files should use the export modifier on assignments that it wishes to make available to client applications and it can refer to variables that don't exist, in which case values for those variables will need to be passed as parameters to the module declaration in the client application.</p>
<pre><code class="dollar">redis= (&quot;redis://localhost:6379/&quot; + ${channel | &quot;test&quot;}) as URI
www= ((&quot;http:get://127.0.0.1:8111/&quot; + ${channel | &quot;test&quot;}) as URI)

export server := {
           www subscribe {
            $1.params &gt;&gt; redis
            { body :  all redis }
        }
    };

export stop := {stop(www);stop(redis); @@ [state(www),state(redis)]}

export state:= [state(www),state(redis)]
</code></pre><h2>Builtin Functions</h2><h2>Concurrency &amp; Threads</h2><p>Notes:</p><p>All types are immutable, including collections. You cannot reassign a variable from a different thread, so they are readonly from other threads.</p><h3>Parallel &amp; Serial Operators</h3><p>The parallel operator <code>|:|</code> or <code>parallel</code> causes the right hand side expression to be evaluated in parallel, it's partner the serial operator <code>|..|</code> or <code>serial</code> forces serial evaluation even if the current expression is being evaluated in parallel.</p>
<pre><code class="dollar"><br/>testList := [ TIME(), {SLEEP(1 Sec); TIME();}, TIME() ];
a= |..| testList;
b= |:| testList;
//Test different execution orders
.: a[2] &gt;= a[1]
.: b[2] &lt; b[1]
</code></pre><p>As you can see the order of evaluation of lists and maps <strong>but not line blocks</strong> is affected by the use of parallel evaluation.</p><h3>Fork</h3><p>The fork operator <code>-&lt;</code> or <code>fork</code> will cause an expression to be evaluated in the background and any reference to the forked expression will block until a value is ready.</p>
<pre><code class="dollar">sleepTime := {@@ &quot;Background Sleeping&quot;;SLEEP(4 Sec); @@ &quot;Background Finished Sleeping&quot;;TIME()}
//Any future reference to c will block until c has completed evaluation
c= fork sleepTime
SLEEP(1 Sec)
@@ &quot;Main thread sleeping ...&quot;
SLEEP(2 Secs)
@@ &quot;Main thread finished sleeping ...&quot;
d= TIME()
.: c &gt; d
</code></pre><p>In the example the value of c is greater than d because the value of c is evaluated in the background. Note that as soon as you make use of the value of c you block until the value is ready. This is exactly the same as Java's Futures.</p><h2>Advanced Topics</h2>